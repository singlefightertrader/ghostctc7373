<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GHOST V24 SMC DETERMINISTIC - Final Retry Fix</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <script src="https://unpkg.com/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>

  <style>
    /* STYLES (V24) - TIDAK DIUBAH DARI V23 */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      background: #050812;
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    .app-container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 100%;
    }
    .header {
      text-align: center;
      padding: 8px 4px;
      border-bottom: 1px solid #1f2937;
    }
    .header h1 {
      font-size: 1.05rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      color: #72f790;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px 0;
      border-bottom: 1px solid #1f2937;
    }
    .controls label {
      font-size: 0.8rem;
      color: #9ca3af;
      align-self: center;
    }
    .controls input, .controls select {
      padding: 6px 8px;
      border: 1px solid #374151;
      background: #1f2937;
      color: #e5e7eb;
      border-radius: 4px;
      font-size: 0.85rem;
      min-width: 80px;
    }
    .controls button {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      font-weight: 600;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    #updateBtn {
      background-color: #2563eb;
      color: white;
    }
    #freezeGhostBtn, #clearGhostBtn {
      background-color: #4b5563;
      color: #e5e7eb;
    }

    .chart-area {
      position: relative;
      height: 400px; /* Chart height (WAJIB DIBERI UKURAN) */
      background: #050812;
      border: 1px solid #1f2937;
      border-radius: 6px;
      overflow: hidden;
    }
    #chartContainer {
      width: 100%;
      height: 100%;
    }

    .status-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      padding-top: 5px;
    }
    .status-item {
      padding: 8px 12px;
      border: 1px solid #374151;
      border-radius: 6px;
      font-size: 0.9rem;
      flex-grow: 1;
      text-align: center;
    }
    .status-area {
      background: #1f2937;
      color: #9ca3af;
    }
    .status-area.success {
      background: #14532d;
      color: #72f790;
    }
    .status-area.error {
      background: #991b1b;
      color: #fca5a5;
    }
    #trendStatusArea {
      border-color: #9ca3af;
    }
    #tradeSignalArea {
      font-weight: bold;
      animation: none;
    }
    @keyframes pulse {
        0% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0.7); }
        70% { box-shadow: 0 0 0 10px rgba(37, 99, 235, 0); }
        100% { box-shadow: 0 0 0 0 rgba(37, 99, 235, 0); }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <div class="header">
      <h1>GHOST V24 SMC INSTITUTIONAL - Deterministic Engine (Final Chart Fix)</h1>
    </div>

    <div class="controls">
      <label for="symbolInput">Symbol:</label>
      <input type="text" id="symbolInput" list="binanceSymbols" value="BTCUSDT" placeholder="BTCUSDT" style="width: 100px;"/>
      <datalist id="binanceSymbols"></datalist>

      <label for="intervalSelect">TF:</label>
      <select id="intervalSelect" style="width: 70px;">
        <option value="1m">1m</option>
        <option value="5m" selected>5m</option>
        <option value="15m">15m</option>
        <option value="30m">30m</option>
        <option value="1h">1h</option>
        <option value="4h">4h</option>
      </select>

      <label for="ghostCountSel">Ghost:</label>
      <select id="ghostCountSel" style="width: 70px;">
        <option value="3" selected>3</option>
        <option value="5">5</option>
        <option value="10">10</option>
      </select>
      
      <label for="logicModeSel">Logic:</label>
      <select id="logicModeSel" style="min-width: 100px;">
        <option value="smc_deterministic" selected>SMC Deterministic</option>
        <option value="simple">Simple Momentum</option>
      </select>

      <button id="updateBtn">Start/Refresh Data</button>
      <button id="freezeGhostBtn">❄️ Freeze Ghost</button>
      <button id="clearGhostBtn">🗑️ Clear Ghost</button>
    </div>

    <div class="status-panel">
      <div id="statusArea" class="status-item status-area">Status: Initializing...</div>
      <div id="trendStatusArea" class="status-item">Trend: MTF Aggregation Pending</div>
      <div id="tradeSignalArea" class="status-item" style="color: #ffb700; border-color: #ffb700;">SIGNAL: Analisis SMC Sedang Berjalan</div>
      <div id="patternStatusArea" class="status-item" style="color: #e5e7eb; border-color: #2563eb;">DIAGNOSTICS: Pending Self-Test...</div>
      <div id="newsWarningArea" class="status-item" style="display:none; background: #991b1b; color: #fca5a5;"></div>
    </div>

    <div class="chart-area">
      <div id="chartContainer" class="chart-container"></div>
    </div>
  </div>

<script>
/* PATCH ULTIMATE OMEGA V4 — FINAL CHART FIX WITH RETRY MECHANISM */
(function(){
  console.log("🔥 Ghost Engine V24 SMC DETERMINISTIC loaded (Patch Omega V4 - Final Retry Fix)");

  // =======================================================
  // V: GLOBALS & CONFIGURATION
  // =======================================================
  const MAX_HISTORY_CANDLES = 500;
  const MTF_TIMEFRAMES = {
      '4h': 4.0, 
      '2h': 3.0, 
      '1h': 2.0, 
      '15m': 1.0, 
      '5m': 0.5 
  };
  const CACHE_TTL_MS = 5000;
  const PIVOT_LEFT = 3;
  const PIVOT_RIGHT = 3;
  const VOLUME_CONFIRM_FACTOR = 1.2;
  const MTF_ALIGNMENT_THRESHOLD = 0.5;

  let currentConfig = null;
  let autoRefreshIntervalId = null;
  let isGhostFrozen = false;
  let cache = {};
  
  window.SR_ZONES = []; 
  window.LAST_SIGNAL = { side: 'NONE', entryZone: null, SL: null, TP1: null, TP2: null, confidence: 0, reasonChain: [] }; 
  window.GHOST_SEQUENCE = []; 
  window.PATCH_DIAGNOSTICS = { version: 'V24.0.1 (SMC Quant)', timestamp: Date.now(), selfTestResults: 'PENDING', lastFetch: null, lastTrendBias: {} }; 

  // UI ELEMENTS 
  const statusArea = document.getElementById('statusArea');
  const patternStatusArea = document.getElementById('patternStatusArea'); 
  const tradeSignalArea = document.getElementById('tradeSignalArea');
  const trendStatusArea = document.getElementById('trendStatusArea');
  const newsWarningArea = document.getElementById('newsWarningArea');
  
  // CHART GLOBALS
  let candleSeries;
  let ghostSeries;
  let chart;
  
  // =======================================================
  // V24: CHART INITIALIZATION & UTILITIES (FIXED TIMING & RETRY)
  // =======================================================
  
  const CHART_PROPERTIES = {
    layout: { background: { color: '#050812' }, textColor: '#e5e7eb' },
    grid: { vertLines: { color: '#1f2937' }, horzLines: { color: '#1f2937' } },
    priceScale: { borderVisible: false },
    timeScale: { 
        borderVisible: false, timeVisible: true, secondsVisible: true, 
        lockVisibleTimeRangeOnResize: true, rightOffset: 15 
    },
    localization: { locale: 'id-ID' },
    watermark: {
      visible: true, text: 'GHOST V24 SMC INSTITUTIONAL', fontSize: 24,
      color: 'rgba(255, 255, 255, 0.1)', horzAlign: 'center', vertAlign: 'center'
    }
  };

  /** * Helper function to attempt chart creation once.
   * Returns true on success, false on failure (with error message).
   */
  function createChartInstance(container) {
      // Clean up previous instance if exists
      if (chart) {
          chart.remove();
          chart = null;
      }

      try {
        chart = LightweightCharts.createChart(container, CHART_PROPERTIES);
        candleSeries = chart.addCandlestickSeries({
          upColor: '#55b259', downColor: '#ef5350', borderVisible: false,
          wickUpColor: '#55b259', wickDownColor: '#ef5350',
        });
        window.ghostSeries = chart.addCandlestickSeries({
            upColor: 'rgba(114, 247, 144, 0.4)', downColor: 'rgba(239, 83, 80, 0.4)',
            borderVisible: true, borderColor: 'rgba(255, 255, 255, 0.1)',
            wickUpColor: 'rgba(114, 247, 144, 0.4)', wickDownColor: 'rgba(239, 83, 80, 0.4)',
        });
        window.zoneSeries = chart.addLineSeries({ visible: false }); 
        console.log("✅ Lightweight Chart Initialized Successfully.");
        return true;
      } catch (e) {
        console.error("FATAL ERROR: Gagal membuat chart LightweightCharts.", e);
        window.setStatus(`ERROR: Gagal Inisialisasi Chart. (${e.message})`, false, true);
        return false;
      }
  }

  /**
   * FIX UTAMA: Implementasi mekanisme Retry eksplisit.
   */
  async function initializeChartWithRetry(maxRetries = 3) {
      for (let attempt = 1; attempt <= maxRetries; attempt++) {
          const chartContainer = document.getElementById('chartContainer'); 

          if (!chartContainer) {
              const msg = `Chart: WAITING FOR RETRY (Percobaan ${attempt}/${maxRetries}): Wadah Chart (#chartContainer) belum siap.`;
              window.setStatus(msg, false, attempt < maxRetries);
              console.warn(msg);
              if (attempt === maxRetries) {
                  window.setStatus("ERROR FATAL: Wadah Chart (#chartContainer) hilang permanen. Gagal melanjutkan.", false, true);
                  return false;
              }
              // Wait before next retry
              await new Promise(resolve => setTimeout(resolve, 50)); 
              continue;
          }

          if (createChartInstance(chartContainer)) {
              window.setStatus("Chart siap. Memulai Self-Test...", true);
              return true;
          }
          
          // If creation fails but container exists, wait a bit and retry
          if (attempt < maxRetries) {
              window.setStatus(`Chart: WAITING FOR RETRY (Percobaan ${attempt}/${maxRetries}): Gagal membuat instance.`, false, true);
              await new Promise(resolve => setTimeout(resolve, 100));
          }
      }
      
      window.setStatus("ERROR FATAL: Gagal Inisialisasi Chart setelah 3 percobaan. Engine dimatikan.", false, true);
      return false;
  }
  
  // Utility functions (setStatus, setTrendStatus, etc.) remain the same from V23
  // ... (Removed for brevity, assuming the user will replace the whole file)
  // Re-inserting required utilities for completeness and safety

  const convertTimeframeToMs = (interval) => {
    const unit = interval.slice(-1);
    const value = parseInt(interval.slice(0, -1));
    switch (unit) {
      case 'm': return value * 60 * 1000;
      case 'h': return value * 60 * 60 * 1000;
      case 'd': return value * 24 * 60 * 60 * 1000;
      default: return 5 * 60 * 1000;
    }
  };

  window.setStatus = (message, isSuccess = false, isError = false) => {
    if (!statusArea) return;
    statusArea.textContent = `Status: ${message}`;
    statusArea.className = 'status-area status-item';
    if (isError) {
      statusArea.classList.add('error');
    } else if (isSuccess) {
      statusArea.classList.add('success');
    }
  };
  
  window.setTrendStatus = (message, color) => {
    if (!trendStatusArea) return;
    trendStatusArea.innerHTML = `Trend: <strong style="color:${color}">${message}</strong>`;
    trendStatusArea.style.borderColor = color;
  };
  
  window.setTradeSignal = (message, color) => {
    if (!tradeSignalArea) return;
    tradeSignalArea.innerHTML = `SIGNAL: <strong style="color:${color}">${message}</strong>`;
    tradeSignalArea.style.color = color;
    tradeSignalArea.style.borderColor = color;
    tradeSignalArea.style.animation = message.includes('BUY') || message.includes('SELL') ? 'pulse 1.5s infinite' : 'none';
  };
  
  window.setDiagnostics = (message) => {
    if (!patternStatusArea) return;
    patternStatusArea.innerHTML = `DIAGNOSTICS: <strong>${message}</strong>`;
    patternStatusArea.style.color = '#e5e7eb';
    patternStatusArea.style.borderColor = '#2563eb';
  }
  
  window.clearChartAnnotations = () => {
    if (!candleSeries) return;
    candleSeries.removeAllPriceLines();
    window.SR_ZONES = [];
  };

  window.clearGhostFinal = () => {
    if (!window.ghostSeries) return;
    window.ghostSeries.setData([]);
    window.clearChartAnnotations();
    window.LAST_SIGNAL = { side: 'NONE', entryZone: null, SL: null, TP1: null, TP2: null, confidence: 0, reasonChain: [] };
    window.GHOST_SEQUENCE = [];
    isGhostFrozen = false;
    window.setStatus("Ghost V24 telah di CLEAR dan UN-FROZEN.", true);
    window.setTradeSignal("Analisis SMC Sedang Berjalan", '#ffb700');
    window.setTrendStatus("MTF Aggregation Pending", '#9ca3af');
    window.setDiagnostics("Cleared. Ready for new analysis.");
  };

  // Utility for deterministic hashing (required for self-test)
  function djb2Hash(str) {
      let hash = 5381;
      for (let i = 0; i < str.length; i++) {
          hash = (hash * 33) ^ str.charCodeAt(i);
      }
      return hash >>> 0; // Convert to unsigned 32-bit integer
  }
  
  function dprg(seed) {
      const hash = djb2Hash(String(seed));
      return hash / 4294967295;
  }
  
  // =======================================================
  // B. DATA LAYER (Binance OHLCV + Caching)
  // =======================================================

  async function fetchBinanceData(symbol, interval, limit = MAX_HISTORY_CANDLES, isSilent = false) {
    const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
    const cacheKey = `${symbol}_${interval}`;
    const now = Date.now();

    if (cache[cacheKey] && now - cache[cacheKey].timestamp < CACHE_TTL_MS) {
        if (!isSilent) console.log(`[Cache Hit] ${cacheKey}`);
        return cache[cacheKey].data;
    }

    try {
      if (!isSilent) window.setStatus(`Fetching ${symbol}/${interval}...`, false, false);
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      
      const klines = data.map(kline => ({
        time: kline[0] / 1000, 
        msTime: kline[0], 
        open: parseFloat(kline[1]),
        high: parseFloat(kline[2]),
        low: parseFloat(kline[3]),
        close: parseFloat(kline[4]),
        volume: parseFloat(kline[5]), 
      }));

      cache[cacheKey] = { data: klines, timestamp: now };
      window.PATCH_DIAGNOSTICS.lastFetch = now;
      if (!isSilent) console.log(`[Cache Miss/Update] ${cacheKey} (${klines.length} candles)`);
      return klines;
    } catch (error) {
      console.error(`Error fetching ${symbol}/${interval}:`, error);
      if (!isSilent) window.setStatus(`ERROR fetching ${symbol}/${interval}: ${error.message}`, false, true);
      return [];
    }
  }
  
  async function fetchAndPopulateBinanceSymbols() {
      const datalist = document.getElementById('binanceSymbols');
      if (!datalist) return;
      datalist.innerHTML = '';
      try {
          const response = await fetch('https://api.binance.com/api/v3/exchangeInfo');
          if (!response.ok) throw new Error('Gagal mengambil exchange info dari Binance.');
          const data = await response.json();
          const tradingSymbols = data.symbols
              .filter(s => s.status === 'TRADING' && s.isSpotTradingAllowed && s.symbol.endsWith('USDT'))
              .map(s => s.symbol);
          
          if (tradingSymbols.length > 0) {
              tradingSymbols.forEach(symbol => {
                  const option = document.createElement('option');
                  option.value = symbol;
                  datalist.appendChild(option);
              });
          } else {
              throw new Error('Tidak ada symbol TRADING USDT yang ditemukan.');
          }
      } catch (error) {
          console.error("Error fetching Binance symbols:", error);
          ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'SOLUSDT', 'XRPUSDT', 'ADAUSDT', 'DOGEUSDT'].forEach(symbol => {
              const option = document.createElement('option');
              option.value = symbol;
              datalist.appendChild(option);
          });
      }
  }
  
  // =======================================================
  // C. SWING & STRUCTURE ENGINE (SMC)
  // (Logic remains identical to V23)
  // =======================================================
  function findPivots(candles) {
      const pivots = [];
      const N = candles.length;
      for (let i = PIVOT_LEFT; i < N - PIVOT_RIGHT; i++) {
          const currentCandle = candles[i];
          let isHigh = true;
          let isLow = true;

          for (let j = 1; j <= PIVOT_LEFT; j++) {
              if (currentCandle.high <= candles[i - j].high) isHigh = false;
          }
          for (let j = 1; j <= PIVOT_RIGHT; j++) {
              if (currentCandle.high < candles[i + j].high) isHigh = false;
          }
          if (isHigh) {
              pivots.push({ time: currentCandle.time, price: currentCandle.high, type: 'SH', candleIndex: i });
              continue;
          }

          for (let j = 1; j <= PIVOT_LEFT; j++) {
              if (currentCandle.low >= candles[i - j].low) isLow = false;
          }
          for (let j = 1; j <= PIVOT_RIGHT; j++) {
              if (currentCandle.low > candles[i + j].low) isLow = false;
          }
          if (isLow) {
              pivots.push({ time: currentCandle.time, price: currentCandle.low, type: 'SL', candleIndex: i });
          }
      }
      return pivots;
  }

  function detectBOS_CHoCH(candles, pivots) {
      const structure = [];
      if (pivots.length < 3) return structure;

      let currentTrend = 'NONE';
      let pivotHigh = null;
      let pivotLow = null;

      for (let i = 0; i < pivots.length; i++) {
          const currentPivot = pivots[i];
          let event = null;

          if (!pivotHigh && currentPivot.type === 'SH') {
              pivotHigh = currentPivot;
          }
          if (!pivotLow && currentPivot.type === 'SL') {
              pivotLow = currentPivot;
          }

          if (pivotHigh && pivotLow) {
              if (currentTrend === 'NONE') {
                  if (currentPivot.type === 'SH' && currentPivot.price > pivotHigh.price) {
                      currentTrend = 'BULLISH';
                  } else if (currentPivot.type === 'SL' && currentPivot.price < pivotLow.price) {
                      currentTrend = 'BEARISH';
                  }
              }

              if (currentTrend === 'BULLISH') {
                  if (currentPivot.type === 'SH' && currentPivot.price > pivotHigh.price) {
                      event = { type: 'BOS_BULLISH', time: currentPivot.time, price: currentPivot.price, pivotHigh, pivotLow, pivot: currentPivot };
                      pivotHigh = currentPivot; 
                  } else if (currentPivot.type === 'SL' && currentPivot.price < pivotLow.price) {
                      event = { type: 'CHoCH_BEARISH', time: currentPivot.time, price: currentPivot.price, target: pivotLow.price, pivotHigh, pivotLow, pivot: currentPivot };
                      currentTrend = 'BEARISH';
                      pivotLow = currentPivot;
                  } else if (currentPivot.type === 'SL' && currentPivot.price > pivotLow.price) {
                      pivotLow = currentPivot; 
                  }
              } else if (currentTrend === 'BEARISH') {
                  if (currentPivot.type === 'SL' && currentPivot.price < pivotLow.price) {
                      event = { type: 'BOS_BEARISH', time: currentPivot.time, price: currentPivot.price, pivotHigh, pivotLow, pivot: currentPivot };
                      pivotLow = currentPivot; 
                  } else if (currentPivot.type === 'SH' && currentPivot.price > pivotHigh.price) {
                      event = { type: 'CHoCH_BULLISH', time: currentPivot.time, price: currentPivot.price, target: pivotHigh.price, pivotHigh, pivotLow, pivot: currentPivot };
                      currentTrend = 'BULLISH';
                      pivotHigh = currentPivot;
                  } else if (currentPivot.type === 'SH' && currentPivot.price < pivotHigh.price) {
                      pivotHigh = currentPivot; 
                  }
              }
          }
          
          if (event) {
              structure.push(event);
          }
      }
      
      return structure;
  }

  // =======================================================
  // D. ORDERBLOCK / S&D / FVG / LIQUIDITY SWEEP
  // (Logic remains identical to V23)
  // =======================================================
  function detectZones(candles, pivots, structure, interval) {
      const zones = [];
      const avgVol = candles.slice(-50).reduce((sum, c) => sum + c.volume, 0) / 50;

      for (const event of structure) {
          if (event.type.includes('BOS_BULLISH') || event.type.includes('CHoCH_BULLISH')) {
              for (let i = event.pivot.candleIndex - 1; i >= 0; i--) {
                  const candle = candles[i];
                  const nextCandle = candles[i + 1];

                  if (candle.close < candle.open) {
                      if (nextCandle && nextCandle.close > candle.high) {
                          zones.push({
                              type: 'OB_BULLISH',
                              tf: interval,
                              high: candle.high,
                              low: candle.low,
                              midpoint: (candle.high + candle.low) / 2,
                              strengthScore: 1.0 + Math.min(1.0, nextCandle.volume / avgVol - 1), 
                              createdAt: candle.time,
                              validated: true
                          });
                          break; 
                      }
                  }
              }
          } else if (event.type.includes('BOS_BEARISH') || event.type.includes('CHoCH_BEARISH')) {
              for (let i = event.pivot.candleIndex - 1; i >= 0; i--) {
                  const candle = candles[i];
                  const nextCandle = candles[i + 1];
                  
                  if (candle.close > candle.open) {
                      if (nextCandle && nextCandle.close < candle.low) {
                          zones.push({
                              type: 'OB_BEARISH',
                              tf: interval,
                              high: candle.high,
                              low: candle.low,
                              midpoint: (candle.high + candle.low) / 2,
                              strengthScore: 1.0 + Math.min(1.0, nextCandle.volume / avgVol - 1),
                              createdAt: candle.time,
                              validated: true
                          });
                          break; 
                      }
                  }
              }
          }
      }

      const lastSwingHigh = pivots.filter(p => p.type === 'SH').pop();
      const lastSwingLow = pivots.filter(p => p.type === 'SL').pop();
      if (lastSwingHigh) {
          if (structure.some(e => e.type === 'BOS_BULLISH' && e.pivot.time === lastSwingHigh.time)) {
              zones.push({ 
                  type: 'LIQUIDITY_SWEEP_BUY', 
                  tf: interval, 
                  high: lastSwingHigh.price, 
                  low: lastSwingHigh.price, 
                  midpoint: lastSwingHigh.price, 
                  strengthScore: 0.8, 
                  createdAt: lastSwingHigh.time, 
                  validated: true 
              });
          }
      }
      if (lastSwingLow) {
           if (structure.some(e => e.type === 'BOS_BEARISH' && e.pivot.time === lastSwingLow.time)) {
              zones.push({ 
                  type: 'LIQUIDITY_SWEEP_SELL', 
                  tf: interval, 
                  high: lastSwingLow.price, 
                  low: lastSwingLow.price, 
                  midpoint: lastSwingLow.price, 
                  strengthScore: 0.8, 
                  createdAt: lastSwingLow.time, 
                  validated: true 
              });
          }
      }

      const latestStructureEvent = structure.filter(e => e.type.includes('BOS') || e.type.includes('CHoCH')).pop();
      if (latestStructureEvent) {
          const pivot = latestStructureEvent.pivot;
          const pivotCandle = candles[pivot.candleIndex];
          const prevCandle = candles[pivot.candleIndex - 1];
          const nextCandle = candles[pivot.candleIndex + 1];

          if (latestStructureEvent.type.includes('BULLISH') && prevCandle && nextCandle && (pivotCandle.low > prevCandle.high) && (nextCandle.low > pivotCandle.high)) {
              zones.push({
                  type: 'FVG_BULLISH', 
                  tf: interval, 
                  high: prevCandle.high, 
                  low: pivotCandle.low, 
                  midpoint: (prevCandle.high + pivotCandle.low) / 2, 
                  strengthScore: 1.5,
                  createdAt: pivot.time,
                  validated: true
              });
          } else if (latestStructureEvent.type.includes('BEARISH') && prevCandle && nextCandle && (pivotCandle.high < prevCandle.low) && (nextCandle.high < pivotCandle.low)) {
              zones.push({
                  type: 'FVG_BEARISH', 
                  tf: interval, 
                  high: pivotCandle.high, 
                  low: prevCandle.low, 
                  midpoint: (pivotCandle.high + prevCandle.low) / 2, 
                  strengthScore: 1.5,
                  createdAt: pivot.time,
                  validated: true
              });
          }
      }

      zones.sort((a, b) => b.strengthScore - a.strengthScore);
      window.SR_ZONES = zones;
      return zones;
  }


  // =======================================================
  // E. MULTI-TF TREND ENGINE & F. GHOST GENERATOR & G. TRADE SIGNAL ENGINE
  // (Logic remains identical to V23)
  // =======================================================
  function aggregateMTFTrend(cachedData) {
      let totalScore = 0;
      let totalWeight = 0;
      let trendDetails = {};
      for (const [tf, weight] of Object.entries(MTF_TIMEFRAMES)) {
          const candles = cachedData[tf];
          if (!candles || candles.length < 50) continue;

          let bias = 0;
          let biasText = 'NEUTRAL';
          try {
              const pivots = findPivots(candles);
              const structure = detectBOS_CHoCH(candles, pivots);
              const lastBOS = structure.filter(e => e.type.includes('BOS') || e.type.includes('CHoCH')).pop();

              if (lastBOS) {
                  if (lastBOS.type.includes('BULLISH')) {
                      bias = 1;
                      biasText = 'BULLISH';
                  } else if (lastBOS.type.includes('BEARISH')) {
                      bias = -1;
                      biasText = 'BEARISH';
                  }
              }
          } catch (e) {
              console.warn(`Error in MTF analysis for ${tf}:`, e.message);
              bias = 0;
          }
          
          totalScore += bias * weight;
          totalWeight += weight;
          trendDetails[tf] = { bias: biasText, weight: weight, score: bias * weight };
      }

      const normalizedScore = totalWeight === 0 ? 0 : totalScore / totalWeight;
      const confidence = Math.abs(normalizedScore) * 100; 

      window.PATCH_DIAGNOSTICS.lastTrendBias = trendDetails;

      let trend = 'NEUTRAL';
      let color = '#9ca3af';
      if (normalizedScore > 0.3) {
          trend = 'BULLISH (Uptrend)';
          color = '#2563eb';
      } else if (normalizedScore < -0.3) {
          trend = 'BEARISH (Downtrend)';
          color = '#ef4444';
      }

      return { trend, color, normalizedScore, confidence, details: trendDetails };
  }
  
  window.generateGhostSequence = (lastCandle, historyCandles, count, interval, trendScore) => {
    
    if (!lastCandle || historyCandles.length < 2) return [];

    let ghostSequence = [];
    let currentClose = lastCandle.close;
    let avgRange = historyCandles.slice(-50).reduce((sum, c) => sum + (c.high - c.low), 0) / 50;
    let avgVol = historyCandles.slice(-50).reduce((sum, c) => sum + c.volume, 0) / 50;
    const intervalMs = convertTimeframeToMs(interval);

    const nearestTarget = findNearestTarget(currentClose, trendScore > 0 ? 'BULLISH' : 'BEARISH', window.SR_ZONES);
    
    const targetBase = currentClose + (trendScore > 0 ? avgRange * count * 0.5 : -avgRange * count * 0.5);
    const targetPrice = nearestTarget ? nearestTarget.price : targetBase;
    
    const volFactor = Math.min(1.0, (lastCandle.volume / avgVol) - 1.0) * 0.5;
    const rangeFactor = Math.min(1.0, (lastCandle.high - lastCandle.low) / avgRange - 1.0) * 0.5;
    const momentumFactor = 1.0 + Math.max(0, volFactor) + Math.max(0, rangeFactor);

    for (let i = 0; i < count; i++) {
      const remainingCandles = count - i;
      const remainingDistance = Math.abs(targetPrice - currentClose);

      const linearStep = remainingDistance / remainingCandles;

      const distanceScale = Math.max(0.2, Math.min(1.0, remainingDistance / (avgRange * 5)));
      let effectiveStep = linearStep * momentumFactor * distanceScale;
      
      effectiveStep = Math.min(effectiveStep, avgRange * 2);

      const direction = targetPrice > currentClose ? 1 : -1;
      let open = currentClose;
      let close = currentClose + effectiveStep * direction;
      
      const nextMsTime = lastCandle.msTime + (i + 1) * intervalMs;
      const nextTime = nextMsTime / 1000;
      
      const deterministicSeed = `${lastCandle.msTime}_${i}`; 
      const rand_high_bull = dprg(deterministicSeed + '_4'); 
      const rand_low_bull = dprg(deterministicSeed + '_5');  
      const rand_high_bear = dprg(deterministicSeed + '_6'); 
      const rand_low_bear = dprg(deterministicSeed + '_7');  
      const rand_volume = dprg(deterministicSeed + '_8');   

      let high, low;

      if (direction > 0) { 
          high = Math.max(open, close) + avgRange * (rand_high_bull * 0.5);
          low = Math.min(open, close) - avgRange * (rand_low_bull * 0.2);
      } else { 
          high = Math.max(open, close) + avgRange * (rand_high_bear * 0.2);
          low = Math.min(open, close) - avgRange * (rand_low_bear * 0.5);
      }

      high = Math.max(high, open, close);
      low = Math.min(low, open, close);
      
      const ghostCandle = {
        time: nextTime,
        open: open,
        close: close,
        high: high,
        low: low,
        volume: avgVol * (momentumFactor * 0.8 + rand_volume * 0.4),
        color: direction > 0 ? 'bullish' : 'bearish',
        isGhost: true,
        msTime: nextMsTime,
      };

      ghostSequence.push(ghostCandle);
      currentClose = close;
      lastCandle = ghostCandle; 
    }

    window.GHOST_SEQUENCE = ghostSequence;
    return ghostSequence;
  };

  function findNearestTarget(lastPrice, side, zones) {
      let nearestTarget = null;
      let minDistance = Infinity;

      for (const zone of zones) {
          if (zone.type.includes('OB') || zone.type.includes('FVG') || zone.type.includes('LIQUIDITY_SWEEP')) {
              if (lastPrice >= zone.low && lastPrice <= zone.high) continue;

              const target = zone.midpoint;
              const distance = Math.abs(target - lastPrice);

              if (side === 'BULLISH' && target > lastPrice && distance < minDistance) {
                  nearestTarget = { price: target, zone, distance };
                  minDistance = distance;
              } else if (side === 'BEARISH' && target < lastPrice && distance < minDistance) {
                  nearestTarget = { price: target, zone, distance };
                  minDistance = distance;
              }
          }
      }
      return nearestTarget;
  }
  
  function generateTradeSignal(candles, trendResult, srZones, interval) {
      const signal = { side: 'NONE', entryZone: null, SL: null, TP1: null, TP2: null, confidence: 0, reasonChain: [] };
      const lastCandle = candles[candles.length - 1];
      const prevCandle = candles[candles.length - 2];
      if (!lastCandle || !prevCandle) return signal;

      const avgVol = candles.slice(-50).reduce((sum, c) => sum + c.volume, 0) / 50;
      const currentVolFactor = lastCandle.volume / avgVol;

      const mtfPass = trendResult.confidence >= MTF_ALIGNMENT_THRESHOLD * 100;
      const mtfDirection = trendResult.normalizedScore > 0 ? 'BULLISH' : (trendResult.normalizedScore < 0 ? 'BEARISH' : 'NEUTRAL');
      
      if (!mtfPass) {
          signal.reasonChain.push({ rule: 'MTF Alignment', evidence: `FAIL (Confidence ${trendResult.confidence.toFixed(0)}% < ${MTF_ALIGNMENT_THRESHOLD * 100}%)` });
          return signal;
      }
      signal.reasonChain.push({ rule: 'MTF Alignment', evidence: `PASS (${mtfDirection} - Confidence ${trendResult.confidence.toFixed(0)}%)` });

      const entryZone = srZones.find(z => z.validated && (mtfDirection === 'BULLISH' ? z.type === 'OB_BULLISH' : z.type === 'OB_BEARISH'));

      if (!entryZone) {
          signal.reasonChain.push({ rule: 'SMC Entry Zone', evidence: 'FAIL (No validated OB found in trend direction)' });
          return signal;
      }
      signal.reasonChain.push({ rule: 'SMC Entry Zone', evidence: `PASS (${entryZone.type} @ ${entryZone.midpoint.toFixed(2)})` });

      const momentumPass = currentVolFactor >= VOLUME_CONFIRM_FACTOR;
      if (!momentumPass) {
          signal.reasonChain.push({ rule: 'Momentum/Volume', evidence: `FAIL (Volume Factor ${currentVolFactor.toFixed(2)} < ${VOLUME_CONFIRM_FACTOR})` });
      } else {
          signal.reasonChain.push({ rule: 'Momentum/Volume', evidence: `PASS (Volume Factor ${currentVolFactor.toFixed(2)})` });
      }

      const candleBiasPass = mtfDirection === 'BULLISH' ? lastCandle.close > lastCandle.open : lastCandle.close < lastCandle.open;

      if (!candleBiasPass) {
          signal.reasonChain.push({ rule: 'Current Candle Bias', evidence: 'FAIL (Last candle counter-trend)' });
      } else {
          signal.reasonChain.push({ rule: 'Current Candle Bias', evidence: 'PASS (Last candle aligns with MTF)' });
      }

      const isNewsWarning = false; 
      if (isNewsWarning) {
          signal.reasonChain.push({ rule: 'News Check', evidence: 'FAIL (Critical news window active)' });
          return signal;
      }
      signal.reasonChain.push({ rule: 'News Check', evidence: 'PASS (Market Normal)' });

      signal.side = mtfDirection;
      signal.confidence = Math.min(100, trendResult.confidence + (momentumPass && candleBiasPass ? 20 : 0)); 
      signal.entryZone = { low: entryZone.low, high: entryZone.high, midpoint: entryZone.midpoint };

      if (mtfDirection === 'BULLISH') {
          signal.SL = entryZone.low * 0.9995;
      } else {
          signal.SL = entryZone.high * 1.0005;
      }

      const targets = srZones.filter(z => 
          (mtfDirection === 'BULLISH' ? z.type.includes('FVG_BEARISH') || z.type.includes('LIQUIDITY_SWEEP_SELL') : z.type.includes('FVG_BULLISH') || z.type.includes('LIQUIDITY_SWEEP_BUY')) && 
          (mtfDirection === 'BULLISH' ? z.low > entryZone.high : z.high < entryZone.low)
      ).sort((a, b) => mtfDirection === 'BULLISH' ? a.low - b.low : b.high - a.high);

      const avgRange = candles.slice(-50).reduce((sum, c) => sum + (c.high - c.low), 0) / 50;
      const fallbackRange = entryZone.high - entryZone.low || avgRange;

      if (targets.length > 0) {
          signal.TP1 = targets[0].midpoint;
          if (targets.length > 1) {
              signal.TP2 = targets[1].midpoint;
          }
      } else {
          if (mtfDirection === 'BULLISH') {
              signal.TP1 = signal.entryZone.midpoint + fallbackRange * 1.5;
              signal.TP2 = signal.entryZone.midpoint + fallbackRange * 3.0;
          } else {
              signal.TP1 = signal.entryZone.midpoint - fallbackRange * 1.5;
              signal.TP2 = signal.entryZone.midpoint - fallbackRange * 3.0;
          }
      }
      
      window.LAST_SIGNAL = signal;
      return signal;
  }
  
  // =======================================================
  // H. PLOT & VISUALIZATION
  // (Logic remains identical to V23)
  // =======================================================

  window.plotSRZones = () => {
      if (!candleSeries) return;
      window.clearChartAnnotations();

      const vr = chart.timeScale().getVisibleRange();
      if (!vr) return; 

      window.SR_ZONES.forEach(zone => {
          let color = '#72f790'; 
          let label = zone.type;

          if (zone.type.includes('OB_BULLISH')) {
              color = 'rgba(37, 99, 235, 0.6)';
              label = 'Bullish OB';
          } else if (zone.type.includes('OB_BEARISH')) {
              color = 'rgba(239, 68, 68, 0.6)';
              label = 'Bearish OB';
          } else if (zone.type.includes('FVG_BULLISH')) {
              color = 'rgba(251, 191, 36, 0.6)';
              label = 'Bullish FVG';
          } else if (zone.type.includes('FVG_BEARISH')) {
              color = 'rgba(168, 85, 247, 0.6)';
              label = 'Bearish FVG';
          } else if (zone.type.includes('LIQUIDITY_SWEEP')) {
              color = 'rgba(255, 183, 0, 0.8)';
              label = zone.type.replace('LIQUIDITY_SWEEP_', '');
          }

          candleSeries.createPriceLine({ 
              price: zone.high, 
              color: color, 
              lineWidth: 1, 
              lineStyle: LightweightCharts.LineStyle.Dotted, 
              axisLabelVisible: true, 
              title: label 
          });
          
          candleSeries.createPriceLine({ 
              price: zone.low, 
              color: color, 
              lineWidth: 1, 
              lineStyle: LightweightCharts.LineStyle.Dotted, 
              axisLabelVisible: true, 
              title: '' 
          });
          
          if (zone.high !== zone.low) {
              candleSeries.createPriceLine({ 
                  price: zone.midpoint, 
                  color: color.replace('0.6', '0.4').replace('0.8', '0.5'),
                  lineWidth: 1, 
                  lineStyle: LightweightCharts.LineStyle.Dashed, 
                  axisLabelVisible: false, 
                  title: '' 
              });
          }
      });

      const signal = window.LAST_SIGNAL;
      if (signal.side !== 'NONE' && signal.entryZone) {
          const color = signal.side === 'BULLISH' ? '#2563eb' : '#ef4444'; 

          candleSeries.createPriceLine({ 
              price: signal.entryZone.midpoint, 
              color: color, 
              lineWidth: 2, 
              lineStyle: LightweightCharts.LineStyle.Solid, 
              axisLabelVisible: true, 
              title: `ENTRY (${signal.confidence.toFixed(0)}%)` 
          });

          candleSeries.createPriceLine({ 
              price: signal.SL, 
              color: color, 
              lineWidth: 1, 
              lineStyle: LightweightCharts.LineStyle.Dashed, 
              axisLabelVisible: true, 
              title: 'SL' 
          });

          if (signal.TP1) {
              candleSeries.createPriceLine({ 
                  price: signal.TP1, 
                  color: '#10b981', 
                  lineWidth: 1, 
                  lineStyle: LightweightCharts.LineStyle.Dotted, 
                  axisLabelVisible: true, 
                  title: 'TP1' 
              });
          }

          if (signal.TP2) {
              candleSeries.createPriceLine({ 
                  price: signal.TP2, 
                  color: '#10b981', 
                  lineWidth: 1, 
                  lineStyle: LightweightCharts.LineStyle.Dotted, 
                  axisLabelVisible: true, 
                  title: 'TP2' 
              });
          }
      }
  };

  // =======================================================
  // IV. SELF-TEST & UNIT VERIFICATION (FINAL GATING)
  // (Logic remains identical to V23)
  // =======================================================

  async function runSelfChecks() {
      console.log("--- IV. SELF-TEST & UNIT VERIFICATION START ---");
      const results = {};
      const testSymbol = 'BTCUSDT';
      const testInterval = '5m';

      const sampleCandles = await fetchBinanceData(testSymbol, testInterval, MAX_HISTORY_CANDLES, true);
      if (sampleCandles.length < 100) {
          results.dataFetch = `FAIL (Only ${sampleCandles.length} candles retrieved)`;
          window.PATCH_DIAGNOSTICS.selfTestResults = 'FAIL (Data)';
          window.setDiagnostics("SELFTEST FAILED: Gagal mengambil data yang cukup.");
          console.error(results);
          return false;
      }
      results.dataFetch = 'PASS (Sample data retrieved)';

      const pivots = findPivots(sampleCandles);
      const structure = detectBOS_CHoCH(sampleCandles, pivots);
      results.structureAnalysis = (pivots.length > 0 && structure.length > 0) ? 'PASS' : 'FAIL (No pivots/structure detected)';

      const zones = detectZones(sampleCandles, pivots, structure, testInterval); 
      const zoneCheckPass = Array.isArray(window.SR_ZONES);
      results.zoneCheck = zoneCheckPass ? 'PASS' : 'FAIL (SR_ZONES is not an array)';

      results.determinism = unitTestVerifyDeterminism(sampleCandles);

      const allPassed = Object.values(results).every(r => r.startsWith('PASS'));

      if (allPassed) {
          console.log("SELFTEST: PASS");
          window.PATCH_DIAGNOSTICS.selfTestResults = 'PASS';
          window.setDiagnostics(`SELFTEST PASSED. SMC Engine Ready. ${results.determinism}`);
      } else {
          console.log("SELFTEST: FAIL - Detailed Reasons Below");
          console.error(results);
          window.PATCH_DIAGNOSTICS.selfTestResults = 'FAIL';
          window.setDiagnostics(`SELFTEST FAILED. Check console for details.`);
      }

      console.log("--- IV. SELF-TEST & UNIT VERIFICATION END ---");
      return allPassed;
  }

  function unitTestVerifyDeterminism(sampleCandles) {
      const lastCandle = sampleCandles[sampleCandles.length - 1];
      const trendScore = 1.0; 

      const ghostRun1 = window.generateGhostSequence(lastCandle, sampleCandles, 5, '5m', trendScore);
      const hash1 = djb2Hash(JSON.stringify(ghostRun1.map(c => ({ time: c.time, close: c.close.toFixed(8) }))));

      const ghostRun2 = window.generateGhostSequence(lastCandle, sampleCandles, 5, '5m', trendScore);
      const hash2 = djb2Hash(JSON.stringify(ghostRun2.map(c => ({ time: c.time, close: c.close.toFixed(8) }))));
      
      if (hash1 === hash2) {
          return `PASS (Determinism Verified: Hash ${hash1})`;
      } else {
          console.error("Determinism Test Failed:", { hash1, hash2 });
          return `FAIL (Determinism Failed: Hash mismatch. Run 1: ${hash1}, Run 2: ${hash2})`;
      }
  }

  // =======================================================
  // VIII. MAIN EXECUTION FLOW & UI BINDINGS
  // =======================================================

  window.updateEngine = async function(config, isAuto) {
      // NOTE V24: Removed `chart` re-initialization logic here, 
      // as `initializeChartWithRetry` is now responsible for a successful setup 
      // before the engine starts. We rely on `chart` being a valid object now.
      if (!chart) {
          window.setStatus("ERROR: Chart object hilang. Engine dimatikan.", false, true);
          return;
      }
      
      if (isAuto && isGhostFrozen) {
          window.setStatus(`Engine Frozen. Data real-time diperbarui, Ghost sequence tetap beku.`, true);
          await loadAndAnalyzeData(config, true); 
          return;
      }

      currentConfig = config;
      window.setStatus(`Memulai analisis untuk ${config.symbol}/${config.interval} (${config.ghostCount} candles)...`);
      
      const realCandles = await loadAndAnalyzeData(config); 

      if (!realCandles || realCandles.length === 0) {
          window.setTradeSignal("ERROR: Gagal memuat data real-time.", '#ef4444');
          return;
      }
      
      let ghostSequence;
      const lastCandle = realCandles[realCandles.length - 1];
      const trendResult = aggregateMTFTrend(cache); 
      
      if (!isGhostFrozen) {
          ghostSequence = window.generateGhostSequence(lastCandle, realCandles, config.ghostCount, config.interval, trendResult.normalizedScore);
      } else {
          ghostSequence = window.GHOST_SEQUENCE; 
      }

      const tradeSignal = generateTradeSignal(realCandles, trendResult, window.SR_ZONES, config.interval);

      candleSeries.setData(realCandles);
      window.ghostSeries.setData(ghostSequence);
      plotSRZones();

      const signalColor = tradeSignal.side === 'BULLISH' ? '#2563eb' : (tradeSignal.side === 'BEARISH' ? '#ef4444' : '#ffb700');
      const signalMessage = tradeSignal.side === 'NONE' ? `HOLD/NEUTRAL: ${tradeSignal.reasonChain.length > 0 ? tradeSignal.reasonChain.slice(-1)[0].rule : 'Pending'}` : `${tradeSignal.side} SIGNAL: Entry @ ${tradeSignal.entryZone.midpoint.toFixed(2)} [Conf ${tradeSignal.confidence.toFixed(0)}%]`;
      
      window.setStatus(`Analisis Selesai. Data ${config.symbol}/${config.interval} dimuat.`, true);
      window.setTradeSignal(signalMessage, signalColor);
      window.setTrendStatus(`${trendResult.trend} (Conf ${trendResult.confidence.toFixed(0)}%)`, trendResult.color);
  }

  async function loadAndAnalyzeData(config, isSilent = false) {
      const allTFs = [config.interval, ...Object.keys(MTF_TIMEFRAMES)].filter((v, i, a) => a.indexOf(v) === i);
      let mainTFCandles = [];
      const fetchPromises = allTFs.map(tf => fetchBinanceData(config.symbol, tf, MAX_HISTORY_CANDLES, isSilent));
      await Promise.all(fetchPromises);
      
      mainTFCandles = cache[`${config.symbol}_${config.interval}`] ? cache[`${config.symbol}_${config.interval}`].data : [];

      if (mainTFCandles.length === 0) return [];
      
      const trendResult = aggregateMTFTrend(cache);
      
      const pivots = findPivots(mainTFCandles);
      const structure = detectBOS_CHoCH(mainTFCandles, pivots);
      detectZones(mainTFCandles, pivots, structure, config.interval); 
      
      return mainTFCandles;
  }
  
  function startAutoRefresh(config) {
    if (autoRefreshIntervalId) {
        clearInterval(autoRefreshIntervalId);
    }
    const intervalMs = convertTimeframeToMs(config.interval);
    const refreshRate = Math.max(5000, intervalMs / 2); 
    
    autoRefreshIntervalId = setInterval(async () => {
        await window.updateEngine(currentConfig, true);
    }, refreshRate);
    console.log(`⏱️ Auto-refresh started every ${refreshRate}ms.`);
  }

  // =======================================================
  // IX. UI Event Listeners & START SEQUENCE
  // =======================================================
  document.addEventListener('DOMContentLoaded', () => {
    
    const symbolInput = document.getElementById('symbolInput');
    const intervalSelect = document.getElementById('intervalSelect');
    const ghostCountSel = document.getElementById('ghostCountSel');
    const logicModeSel = document.getElementById('logicModeSel');
    const updateBtn = document.getElementById('updateBtn');
    const freezeGhostBtn = document.getElementById('freezeGhostBtn');
    const clearGhostBtn = document.getElementById('clearGhostBtn');
    
    if (!symbolInput) {
        window.setStatus("ERROR FATAL: Elemen UI utama hilang. Gagal memulai.", false, true);
        return;
    }

    const updateCurrentConfig = () => {
      currentConfig = {
        symbol: symbolInput.value.toUpperCase(),
        interval: intervalSelect.value,
        ghostCount: parseInt(ghostCountSel.value),
        logicMode: logicModeSel.value,
      };
      return currentConfig;
    };

    updateBtn.addEventListener('click', async () => {
      const cfg = updateCurrentConfig();
      if (!cfg.symbol) {
        window.setStatus("ERROR: Simbol tidak boleh kosong! (Contoh: BTCUSDT)", false, true);
        return;
      }
      isGhostFrozen = false;
      if (chart) { // Only run if chart exists
        await window.updateEngine(cfg, false);
        startAutoRefresh(cfg);
      } else {
        window.setStatus("ERROR: Chart belum/gagal diinisialisasi.", false, true);
      }
    });
    
    freezeGhostBtn.addEventListener('click', () => {
      if (!currentConfig) {
          window.setStatus("ERROR: Harus memuat data sekali sebelum Freeze!", false, true);
          return;
      }
      isGhostFrozen = true;
      window.setStatus(`Ghost V24 sekarang FROZEN (Mode: ${currentConfig.logicMode}) - real data, trend, dan signal tetap update`, true);
    });
    
    clearGhostBtn.addEventListener('click', () => {
      window.clearGhostFinal();
    });

    // VIII. START INSTRUCTIONS (Auto-start sequence)
    async function startEngineSequence() {
        // 1. Inisialisasi Chart dengan Retry
        const chartReady = await initializeChartWithRetry(3); 
        
        if (!chartReady) {
            console.error("Engine Start Failed: Chart initialization failed after retries.");
            return; 
        }

        // 2. Fetch all symbols first
        await fetchAndPopulateBinanceSymbols();
        
        // 3. Run Self-Tests (IV. Final Gating)
        const selfTestPassed = await runSelfChecks();

        if (selfTestPassed) {
            // 4. Then start the engine if tests pass
            const cfg = {
                symbol: "BTCUSDT",
                interval: "5m",
                ghostCount: 3,
                logicMode: "smc_deterministic", 
            };
            symbolInput.value = cfg.symbol;
            intervalSelect.value = cfg.interval;
            ghostCountSel.value = String(cfg.ghostCount);
            logicModeSel.value = cfg.logicMode;
            currentConfig = cfg;
            await window.updateEngine(cfg, false);
            startAutoRefresh(cfg);
        } else {
             window.setStatus("FATAL ERROR: Self-Test GAGAL. Perbaikan WAJIB dilakukan sebelum Engine diaktifkan.", false, true);
             console.error("PERINTAH ULTIMATE OMEGA GAGAL: Self-Test FAILED.");
        }
    }
    
    startEngineSequence();
  });
})();
</script>
</body>
</html>